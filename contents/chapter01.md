# 1장 스프링, 클라우드와 만나다

## 1.1 마이크로서비스 아키텍처로 진화

1. 모놀리스 아키텍쳐

- 장점
  - 모든 UI, 비즈니스 및 데이터베이스 액세스 로직이 하나로 배포
  - 관리가 쉬움
  - 구축 및 배포가 쉬움
  - 변경 가능성이 낮은 경우 모놀리스로 시작하는게 좋음
- 단점
  - 규모가 커지면 관리가 어려움

1. 마이크로서비스 아키텍쳐

- 장점
  - 각 구성 요소는 작은 책임 영역을 담당하고 서로 독립적 배포
  - 잘 분해하고 분리하면 대규모 코드베이스에서 발생하는 전통적인 복잡성 문제를 해결하는데 도움이 됨
- 단점
  - 잘 분해라고 분리하기가 어려움
  - 여러 저장소로 나누어지기 때문에 개인이 관리하기 힘듬(12 저장소 관리..)
  - CCOP(Complex, Consistency, Operation overhead, Performance) 문제점

## 1.4 이 책의 내용

- 마이크로서비스의 정의, 모범 사례 및 마이크로서비스 기반 구축을 위한 설계 고려 사항
- 마이크로서비스 기반 애플리케이션을 구축하면 안되는 경우(중요..)
- 도커의 정의 및 마이크로서비스 기반 애플리케이션 통합 방법
- 애플리케이션 지표를 만들고 모니터링 도구로 시각화 방법
- ELK 스택으로 애플리케이션 로그 관리 방법
- 배운 내용 활용하여 배포 파이프라인 구축 방법(CI/CD?)

## 1.5 클라우드 및 마이크로서비스 기반 애플리케이션

실습코드 참조 [코드](https://github.com/haservi/book-spring-microservice-kotlin/tree/main/chapter1)

클라우드 컴퓨팅에서는 여러 가지 서비스 모델

IaaS (Infrastructure as a Service)

- 설명: IaaS는 인프라를 서비스로 제공하는 모델로, 사용자에게 서버, 스토리지, 네트워크 등의 가상화된 자원을 제공. 사용자는 인프라의 운영 체제, 네트워크 설정 등을 직접 관리하지만, 물리적인 하드웨어는
  클라우드 제공자가 관리
- 예시: Amazon Web Services (AWS) EC2, Microsoft Azure, Google Cloud Platform (GCP)
- 특징: 유연성과 확장성이 뛰어나며, 자원을 필요에 따라 쉽게 추가하거나 제거할 수 있음

SaaS (Software as a Service)

- 설명: SaaS는 소프트웨어를 인터넷을 통해 제공하는 서비스 모델로, 사용자는 설치나 유지보수 없이 웹 브라우저나 애플리케이션을 통해 소프트웨어를 사용할 수 있음. 애플리케이션의 모든 관리와 업데이트는 서비스
  제공자가 수행
- 예시: Google Workspace (Gmail, Google Docs), Salesforce, Microsoft 365
- 특징: 사용자가 소프트웨어를 직접 설치하거나 관리할 필요가 없고, 언제 어디서나 인터넷 연결만 있으면 접근 가능

PaaS (Platform as a Service)

- 설명: PaaS는 개발자들이 애플리케이션을 개발하고 배포할 수 있는 플랫폼을 제공. 이 플랫폼은 운영 체제, 미들웨어, 데이터베이스 관리 시스템 등을 포함하며, 개발자가 인프라 관리 없이 애플리케이션 개발에
  집중할 수 있음
- 예시: Google App Engine, Microsoft Azure App Service, Heroku
- 특징: 개발 환경을 빠르게 설정하고 관리할 수 있어 개발 시간을 단축하고, 복잡한 인프라 운영을 클라우드 제공자가 처리

CaaS (Container as a Service)

- 설명: CaaS는 컨테이너화된 애플리케이션을 배포하고 관리할 수 있는 환경을 제공. Docker와 Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 애플리케이션을 쉽게 배포하고 확장할 수 있음
- 예시: Amazon ECS, Google Kubernetes Engine (GKE), Microsoft Azure Kubernetes Service (AKS)
- 특징: 컨테이너 기반 애플리케이션의 빠른 배포와 확장성이 용이하며, DevOps 환경에서 특히 유용

FaaS (Function as a Service)

- 예시: AWS Lambda, Google Cloud Functions, Azure Functions.
- 설명: FaaS는 이벤트 기반으로 특정 기능(코드)을 실행할 수 있는 서버리스 컴퓨팅 모델. 사용자는 코드를 작성하고 업로드하면, 서비스 제공자가 이를 실행하고 필요할 때만 비용이 발생. 인프라와 서버 관리를
  하지 않아도 되며, 트리거 기반으로 애플리케이션이 작동
- 특징: 서버리스 환경으로, 특정 이벤트에 반응하여 실행되며, 애플리케이션 규모가 유동적일 때 유리

DaaS (Desktop as a Service)

- 설명: DaaS는 가상 데스크탑 환경을 클라우드에서 제공하는 서비스. 사용자는 클라우드 상에서 가상 데스크탑에 접속하여 업무를 수행할 수 있으며, 데스크탑의 운영 체제 및 애플리케이션도 클라우드에서 관리
- 예시: Amazon WorkSpaces, VMware Horizon Cloud
- 특징: 물리적인 PC 없이도 언제 어디서나 데스크탑 환경에 접근할 수 있으며, 보안 관리 및 업데이트가 중앙에서 이루어짐

## 1.6 마이크로서비스는 코드 작성 이상을 의미한다.

견고한 서비스를 작성하려면 아래와 같이 여러 가지 주제를 고려해야 함

- 적정 규모: 서비스가 한 가지 책임 영역에 집중되도록 하려면 어떻게 해야 하는가?
- 마이크로서비스가 너무 많은 책임을 지지 않도록 적절한 마이크로서비스 크기를 유지하는 방법
- 위치 투명성: 서비스 호출에 대한 물리적 상세 정보를 관리하는 방법. 마이크로서비스 애플리케이션에서 다수의 서비스 인스턴스가 빠르게 시작하고 종료
- 회복성: 실패한 서비스를 우회하고 빠른 실패 방식을 적용하여 마이크로서비스 소비자와 애플리케이션의 전반적인 무결성을 보호하는 방법
- 반복성: 서비스의 모든 새 인스턴스가 시작할 떄 운영 환경의 다른 서비스와 동일한 구성과 코드베이스를 보장하는 방법
- 확장성: 서비스 간 직접적인 종속 관계를 최소화하고 마이크로서비스를 적절히 확장할 수 있도록 통신 방식을 구축하는 방법
- 핵심 마이크로서비스 개발, 라우팅, 클라이언트 탄력성, 보안, 로깅 및 추적, 애플리케이션 지표, 빌드 및 배포 패턴

## 1.7 핵심 마이크로서비스 개발 패턴

![image](./docs/images/chapter1/image01.png)

- 서비스 세분성: 서비스를 서로 다른 비즈니스 문제 도메인의 책임과 중첩될 정도로 지나치게 크게 나누면 시간이 지나 유지 관리하고 변경하기 어려움
- 통신 프로토콜: 동기 프로토콜의 경우 HTTP 기반 REST가 일반적인 통신이며, 비동기 프로토콜의 경우 아파치 카프카, RabbitMQ, AMQP 등을 사용
- 인터페이스 설계: 서비스 인터페이스 설계 및 서비스를 어떻게 구조화 하는게 좋을 지(2장에서 다룰 예정)
- 서비스 구성 관리: 클라우드에 있는 서로 다른 환경 간 마이크로서비스의 구성을 호환하려면 어떻게 구성 관리 해야하는지 (5장에서 다룰 예정)
- 서비스 간 이벤트 처리: 서비스간 의존성을 최소화하고 애플리케이션의 탄력성을 높이고자 이벤틀르 사용하여 서비스를 분리하는 방법은 어떻게 하는지(10장에서 다룰 예정(스프링 클라우드 스트림))

## 1.8 마이크로서비스 라우팅 패턴

마이크로서비스 라우팅 패턴은 마이크로서비스를 사용하려는 클라이언트 애플리케이션이 서비스 위치를 발견하고 서비스로 라우팅하는 방법에 관한 방법

- 서비스 디스커버리: 6장에서 자세히 다룰 예정이며, 서비스 디스커버리는 클라이언트 대응 서비스가 아니라 내부 서비스임을 기억하는게 좋음
- 서비스 라우팅: API 게이트웨이를 사용하면 모든 서비스에 대한 단일 진입점을 제공하여 마이크로서비스 애플리케이션의 여러 서비스와 서비스 인스턴스에 대해 일관된 보안 정책과 라우팅 규칙을 적용할 수 있음(8장에서
  자세히 다룰 예정)

## 1.9 마이크로서비스 클라이언트 회복성

서비스 문제 발생 시 연쇄적으로 서비스 소비자까지 전파되는 것을 막는 것이 중요합니다. 이와 관련된 4가지의 클라이언트 회복성 패턴

- 클라이언트 부하 분산: 여러 인스턴스에 대한 호출이 정상 인스턴스에 분산되도록 서비스 인스턴스 위치를 캐싱하는 방법
- 회로 차단기 패턴: 문제가 있는 서비스 호출하지 않는 방법
- 폴백 패턴: 마이크로서비스 호출 실패 시 다른 서비스 클라이언트가 작업을 수행하도록 플러그인 메커니즘을 제공하는 방법
- 벌크헤드 패턴: 한 서비스의 오작동 호출이 애플리케이션의 다른 곳에 나쁜 영향을 미치지 않도록 호출을 격리하는 방법

## 1.10 마이크로서비스 보안 패턴

적절한 자격 증명을 가진 승인된 요청만 서비스를 호출할 수 있도록 할 수 있는 3가지의 보안 패턴 방법

- 인증: 서비스를 호출하는 서비스 클라이언트가 누구인지 확인하는 방법
- 인가(권한 부여): 서비스 클라이언트가 수행하려는 행동에 대한 수행 자격 여부를 확인하는 방법
- 자격 증명 관리와 전파: OAuth2와 JWT 같은 토큰 기반의 보안 표준 사용 방법

## 1.11 마이크로서비스 로깅과 추적 패턴

마이크로서비스 아키텍처의 단점은 간단한 동작 하나에 수많은 마이크로서비스 호출이 발생하여 문제를 디버깅하고 추적 및 모니터링하기가 매우 어려움  
이를 해결하기 위해 분산 추적을 달성하는 세 가지 핵심 로깅 및 추적 패턴

- 로그 상관관계: 한 트랜잭션에 대해 여러 서비스에서 생서된 모든 로그를 함께 연결하는 상관관계 ID(correlation ID)를 구현하는 방법
- 로그 수집: 마이크로서비스가 출력한 모든 로그를 수집하여 확인하는 방법
- 마이크로서비스 추적: 트랜잭션과 관련된 모든 서비스 간 클라이언트 트랜잭션 흐름을 시각화하고 성능 특성을 살펴보는 방법

## 1.12 애플리케이션 지표 패턴

애플리케이션 지표 패턴은 애플리케이션이 지표를 모니터링 하는 방법과 애플리케이션의 가능한 실패 원인을 경고하는 방법

해당 패턴은 서비스의 잠재적인 성능 문제를 방지하고자 지표 서비스가 비즈니스와 연관된 데이터를 수집, 저장, 질의하는 방법을 보여줌

- 지표: 애플리케이션 상태에 대해 중요한 정보를 생성하고 이 정보의 지표를 노출하는 방법
- 지표 서비스: 애플리케이션 지표를 저장하고 질의하는 곳
- 지표 시각화 제품군: 애플리케이션과 인프라스트럭처에 대해 비즈니스와 연관된 시계열 데이터를 시각화

![image](./docs/images/chapter1/image02.png)

**지표 모니터링은 마이크로서비스 아키텍처에 필수적**이며, 마이크로서비스의 높은 분산성으로 인해 모놀리식 구조보다 더 높은 경향이 있음(복잡하고 어렵다?)

## 1.13 마이크로서비스 빌드/배포 패턴

마이크로서비스 아키텍처의 핵심 부분 중 하나는 한 마이크로서비스의 각 인스턴스가 모두 동일해야 함

서버가 배포된 후 서버의 변경 사항으로 발생되는 구성 불일치는 애플리케이션의 안정성을 해칠 수 있어 발생을 막아야 함

빌드 및 배포 파이프라인을 구축하는 방법

- 빌드 및 배포 파이프라인: 조직의 모든 환경에서 원 버튼 클릭 빌드와 배포를 중시하는 반복적인 빌드 및 배포 프로세스를 구축하는 방법
- 코드형 인프라스트럭처: 소스 제어로 실행되고 관리되는 서비스 프로비저닝 처리 방법
- 불변 서버: 마이크로서비스 이미지가 생성되고 배포된 후 절대 변경되지 않도록 하는 방법
- 피닉스 서버: 개별 컨테이너를 실행하는 서버가 정기적으로 분해되어 불변 이미지로 재생성되도록 하는 방법

![image](./docs/images/chapter1/image03.png)
